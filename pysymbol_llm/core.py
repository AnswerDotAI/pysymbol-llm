"""Create a list of symbols in a python package"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto 0
__all__ = ['format_symbol', 'is_public_symbol', 'is_valid_method', 'get_decorators', 'log_error', 'get_params',
           'process_function', 'process_class', 'get_public_symbols', 'generate_markdown', 'pysym2md']

# %% ../nbs/00_core.ipynb 2
import importlib
import pkgutil
from astroid import MANAGER, FunctionDef, ClassDef
from fastcore.utils import Path
from fastcore.script import call_parse, store_false, store_true, Param

# %% ../nbs/00_core.ipynb 5
def format_symbol(name, signature, doc, decorators=None, is_method=False):
    "format the information in markdown"
    params = signature.split('(', 1)[1].rsplit(')', 1)[0] if '(' in signature else ''
    decorator_str = ' '.join(f'@{d}' for d in decorators) + ' ' if decorators else ''
    formatted = f"- `{decorator_str.strip()}{' ' if decorator_str else ''}{'def ' if not is_method else ''}{name}({params})`\n"
    if doc:
        doc_lines = doc.strip().split('\n')
        formatted += '    ' + '\n    '.join(doc_lines) + '\n'
    return formatted

# %% ../nbs/00_core.ipynb 8
def is_public_symbol(name): return not name.startswith('_') or (name.startswith('__') and name.endswith('__'))
def is_valid_method(method, method_name): return isinstance(method, FunctionDef) and is_public_symbol(method_name)
def get_decorators(obj): return [d.as_string() for d in obj.decorators.nodes] if obj.decorators else []
def log_error(name, error): raise RuntimeError(f"Error processing symbol {name}: {str(error)}")

# %% ../nbs/00_core.ipynb 9
def get_params(func):
    params = []
    for arg in func.args.args: params.append(arg.name)
    if func.args.vararg: params.append(f"*{func.args.vararg}")
    if func.args.kwarg: params.append(f"**{func.args.kwarg}")
    return ', '.join(params)

# %% ../nbs/00_core.ipynb 10
def process_function(func, name, include_no_docstring):
    "Parse functions"
    params = get_params(func)
    signature = f"{name}({params})"
    doc = func.doc_node.value if func.doc_node else ""
    decorators = get_decorators(func)
    if include_no_docstring or doc:
        return ('function', name, signature, doc, decorators)
    return None

# %% ../nbs/00_core.ipynb 12
def _process_method(method, method_name):
    method_params = get_params(method)
    method_signature = f"{method_name}({method_params})"
    method_doc = method.doc_node.value if method.doc_node else ""
    method_decorators = get_decorators(method)
    return (method_name, method_signature, method_doc, method_decorators)

def process_class(cls, name, include_no_docstring):
    "Parse classes."
    class_doc = cls.doc_node.value if cls.doc_node else ""
    class_decorators = get_decorators(cls)
    methods = [_process_method(method, method_name) 
               for method_name, method in cls.items() 
               if is_valid_method(method, method_name)]
    return ('class', name, class_doc, class_decorators, methods)

# %% ../nbs/00_core.ipynb 15
def get_public_symbols(module, include_no_docstring):
    "Extract all public symbols"
    symbols = []
    for name, obj in module.items():
        if is_public_symbol(name):
            try:
                if isinstance(obj, FunctionDef):
                    symbol = process_function(obj, name, include_no_docstring)
                    if symbol: symbols.append(symbol)
                elif isinstance(obj, ClassDef):
                    symbols.append(process_class(obj, name, include_no_docstring))
            except Exception as e: log_error(name, e)
    return symbols

# %% ../nbs/00_core.ipynb 17
def generate_markdown(package_name, include_no_docstring, verbose=False):
    markdown = [f"# {package_name} Module Documentation\n\n"]
    
    try: package = importlib.import_module(package_name)
    except ImportError: raise ImportError(f"Could not import package {package_name}. Is it installed?")

    for _, module_name, _ in pkgutil.walk_packages(package.__path__, package.__name__ + '.'):
        try:
            if verbose: print(f"Processing module: {module_name}")
            module = MANAGER.ast_from_module_name(module_name)
            symbols = get_public_symbols(module, include_no_docstring)
            
            if symbols:
                markdown.append(f"## {module_name}\n\n")
                module_doc = module.doc_node.value if module.doc_node else ""
                
                if module_doc:
                    markdown.append("> " + "\n> ".join(module_doc.strip().split('\n')) + "\n\n")
                
                for symbol in symbols:
                    if symbol[0] == 'function':
                        _, name, signature, doc, decorators = symbol
                        decorator_str = ' '.join(f'@{d}' for d in decorators)
                        markdown.append(f"- `{decorator_str + ' ' if decorator_str else ''}def {signature}`\n")
                        if doc:
                            markdown.append(f"    {doc.strip()}\n\n")
                    elif symbol[0] == 'class':
                        _, name, class_doc, class_decorators, methods = symbol
                        decorator_str = ' '.join(f'@{d}' for d in class_decorators)
                        markdown.append(f"- `{decorator_str + ' ' if decorator_str else ''}class {name}`\n")
                        if class_doc:
                            markdown.append(f"    {class_doc.strip()}\n\n")
                        for method_name, method_signature, method_doc, method_decorators in methods:
                            method_decorator_str = ' '.join(f'@{d}' for d in method_decorators)
                            markdown.append(f"    - `{method_decorator_str + ' ' if method_decorator_str else ''}def {method_signature}`\n")
                            if method_doc:
                                markdown.append(f"        {method_doc.strip()}\n\n")
                        markdown.append("\n")
            else:
                if verbose: print(f"No public symbols found in {module_name}")
        except Exception as e:
            raise RuntimeError(f"Error processing {module_name}: {str(e)}")
        
    return ''.join(markdown)

# %% ../nbs/00_core.ipynb 22
@call_parse
def pysym2md(package_name:Param("Name of the Python package", str),
             include_no_docstring:Param("Include symbols without docstrings?", store_true)=False,
             verbose:Param("Turn on verbose logging?", store_true)=False,
             output_file:Param("The output file", str)='filelist.md',
                         ):
    "Generate a list of symbols corresponding to a python package in a markdown format."
    markdown_content = generate_markdown(package_name, include_no_docstring, verbose)
    Path(output_file).write_text(markdown_content)
    if verbose: print(f"Documentation generated in {output_file}")
