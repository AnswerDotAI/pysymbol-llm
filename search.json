[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "Once you collect symbols, you want to format it as a markdown list\n\nsource\n\n\n\n format_symbol (name, signature, doc, decorators=None, is_method=False)\n\nformat the information in markdown",
    "crumbs": [
      "core"
    ]
  },
  {
    "objectID": "core.html#format-symbols",
    "href": "core.html#format-symbols",
    "title": "core",
    "section": "",
    "text": "Once you collect symbols, you want to format it as a markdown list\n\nsource\n\n\n\n format_symbol (name, signature, doc, decorators=None, is_method=False)\n\nformat the information in markdown",
    "crumbs": [
      "core"
    ]
  },
  {
    "objectID": "core.html#parse-symbols-in-the-module",
    "href": "core.html#parse-symbols-in-the-module",
    "title": "core",
    "section": "Parse Symbols In The Module",
    "text": "Parse Symbols In The Module\nNext we parse symbols in the module that we want to list.\n\nsource\n\nlog_error\n\n log_error (name, error)\n\n\nsource\n\n\nget_decorators\n\n get_decorators (obj)\n\n\nsource\n\n\nis_valid_method\n\n is_valid_method (method, method_name)\n\n\nsource\n\n\nis_public_symbol\n\n is_public_symbol (name)\n\n\nsource\n\n\nget_params\n\n get_params (func)\n\n\nsource\n\n\nprocess_function\n\n process_function (func, name, include_no_docstring)\n\nParse functions\n\nsource\n\n\nprocess_class\n\n process_class (cls, name, include_no_docstring)\n\nParse classes.\nFor example, this is how a Class will be parsed:\n\nmock_class = extract_node('''\n@decorator\nclass TestClass:\n    \"\"\"\n    Class docstring\n    with multiple lines\n    \"\"\"\n    @staticmethod\n    def method1(arg1):\n        \"\"\"\n        Method1 docstring\n        with multiple lines\n        \"\"\"\n        pass\n    def method2(self):\n        \"\"\"Single line docstring\"\"\"\n        pass\n''')\n\n# Process the class\nresult = process_class(mock_class, \"TestClass\", True)\n\n# Test equality\ntest_eq(result, (\n    'class',\n    'TestClass',\n    '\\n    Class docstring\\n    with multiple lines\\n    ',\n    ['decorator'],\n    [\n        ('method1', 'method1(arg1)', '\\n        Method1 docstring\\n        with multiple lines\\n        ', ['staticmethod']),\n        ('method2', 'method2(self)', 'Single line docstring', [])\n    ]\n))\n\n\nsource\n\n\nget_public_symbols\n\n get_public_symbols (module, include_no_docstring)\n\nExtract all public symbols\n\nsource\n\n\ngenerate_markdown\n\n generate_markdown (package_name, include_no_docstring, verbose=False)\n\nHere is a preview of the fastcore library, for instance:\n\n_md = generate_markdown('fastcore', False)\n_lns = _md.splitlines()\nprint('\\n'.join([x for x in _lns][:55]))\n\n# fastcore Module Documentation\n\n## fastcore.basics\n\n&gt; Basic functionality used in the fastai library\n\n- `def ifnone(a, b)`\n    `b` if `a` is None else `a`\n\n- `def maybe_attr(o, attr)`\n    `getattr(o,attr,o)`\n\n- `def basic_repr(flds)`\n    Minimal `__repr__`\n\n- `def is_array(x)`\n    `True` if `x` supports `__array__` or `iloc`\n\n- `def listify(o, *rest)`\n    Convert `o` to a `list`\n\n- `def tuplify(o, use_list, match)`\n    Make `o` a tuple\n\n- `def true(x)`\n    Test whether `x` is truthy; collections with &gt;0 elements are considered `True`\n\n- `class NullType`\n    An object that is `False` and can be called, chained, and indexed\n\n    - `def __getattr__(self, *args)`\n    - `def __call__(self, *args, **kwargs)`\n    - `def __getitem__(self, *args)`\n    - `def __bool__(self)`\n\n- `def tonull(x)`\n    Convert `None` to `null`\n\n- `def get_class(nm, *fld_names, **flds)`\n    Dynamically create a class, optionally inheriting from `sup`, containing `fld_names`\n\n- `def mk_class(nm, *fld_names, **flds)`\n    Create a class using `get_class` and add to the caller's module\n\n- `def wrap_class(nm, *fld_names, **flds)`\n    Decorator: makes function a method of a new class `nm` passing parameters to `mk_class`\n\n- `class ignore_exceptions`\n    Context manager to ignore exceptions\n\n    - `def __enter__(self)`\n    - `def __exit__(self, *args)`\n\n- `def exec_local(code, var_name)`\n    Call `exec` on `code` and return the var `var_name`",
    "crumbs": [
      "core"
    ]
  },
  {
    "objectID": "core.html#write-markdown-to-file",
    "href": "core.html#write-markdown-to-file",
    "title": "core",
    "section": "Write markdown to file",
    "text": "Write markdown to file\nWe can generate our list of symbols as a markdown file like so:\n\nsource\n\npysym2md\n\n pysym2md (package_name:str&lt;NameofthePythonpackage&gt;,\n           include_no_docstring:&lt;Includesymbolswithoutdocstrings?&gt;=False,\n           verbose:&lt;Turnonverboselogging?&gt;=False,\n           output_file:str&lt;Theoutputfile&gt;='filelist.md')\n\nGenerate a list of symbols corresponding to a python package in a markdown format.\n\npysym2md('fastcore')",
    "crumbs": [
      "core"
    ]
  },
  {
    "objectID": "filelist.html",
    "href": "filelist.html",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "Basic functionality used in the fastai library\n\n\ndef ifnone(a, b) b if a is None else a\ndef maybe_attr(o, attr) getattr(o,attr,o)\ndef basic_repr(flds) Minimal __repr__\ndef is_array(x) True if x supports __array__ or iloc\ndef listify(o, *rest) Convert o to a list\ndef tuplify(o, use_list, match) Make o a tuple\ndef true(x) Test whether x is truthy; collections with &gt;0 elements are considered True\nclass NullType An object that is False and can be called, chained, and indexed\n\ndef __getattr__(self, *args)\ndef __call__(self, *args, **kwargs)\ndef __getitem__(self, *args)\ndef __bool__(self)\n\ndef tonull(x) Convert None to null\ndef get_class(nm, *fld_names, **flds) Dynamically create a class, optionally inheriting from sup, containing fld_names\ndef mk_class(nm, *fld_names, **flds) Create a class using get_class and add to the caller’s module\ndef wrap_class(nm, *fld_names, **flds) Decorator: makes function a method of a new class nm passing parameters to mk_class\nclass ignore_exceptions Context manager to ignore exceptions\n\ndef __enter__(self)\ndef __exit__(self, *args)\n\ndef exec_local(code, var_name) Call exec on code and return the var var_name\ndef risinstance(types, obj) Curried isinstance but with args reversed\nclass Inf Infinite lists\ndef in_(x, a) True if x in a\ndef ret_true(*args, **kwargs) Predicate: always True\ndef ret_false(*args, **kwargs) Predicate: always False\ndef stop(e) Raises exception e (by default StopIteration)\ndef gen(func, seq, cond) Like (func(o) for o in seq if cond(func(o))) but handles StopIteration\ndef chunked(it, chunk_sz, drop_last, n_chunks) Return batches from iterator it of size chunk_sz (or return n_chunks total)\ndef otherwise(x, tst, y) y if tst(x) else x\ndef custom_dir(c, add) Implement custom __dir__, adding add to cls\nclass AttrDict dict subclass that also provides access to keys as attrs\n\ndef __getattr__(self, k)\ndef __setattr__(self, k, v)\ndef __dir__(self)\ndef copy(self)\n\nclass AttrDictDefault AttrDict subclass that returns None for missing attrs\n\ndef __init__(self, *args, **kwargs)\ndef __getattr__(self, k)\n\nclass NS SimpleNamespace subclass that also adds iter and dict support\n\ndef __iter__(self)\ndef __getitem__(self, x)\ndef __setitem__(self, x, y)\n\ndef get_annotations_ex(obj) Backport of py3.10 get_annotations that returns globals/locals\ndef eval_type(t, glb, loc) eval a type or collection of types, if needed, for annotations in py3.10+\ndef type_hints(f) Like typing.get_type_hints but returns {} if not allowed type\ndef annotations(o) Annotations for o, or type(o)\ndef anno_ret(func) Get the return annotation of func\ndef signature_ex(obj, eval_str) Backport of inspect.signature(..., eval_str=True to &lt;py310\ndef argnames(f, frame) Names of arguments to function or frame f\ndef with_cast(f) Decorator which uses any parameter annotations as preprocessing functions\ndef store_attr(names, self, but, cast, store_args, **attrs) Store params named in comma-separated names from calling context into attrs in self\ndef attrdict(o, *ks) Dict from each k in ks to getattr(o,k)\ndef properties(cls, *ps) Change attrs in cls with names in ps to properties\ndef camel2words(s, space) Convert CamelCase to ‘spaced words’\ndef camel2snake(name) Convert CamelCase to snake_case\ndef snake2camel(s) Convert snake_case to CamelCase\ndef class2attr(self, cls_name) Return the snake-cased name of the class; strip ending cls_name if it exists.\ndef getcallable(o, attr) Calls getattr with a default of noop\ndef getattrs(o, *attrs) List of all attrs in o\ndef hasattrs(o, attrs) Test whether o contains all attrs\ndef try_attrs(obj, *attrs) Return first attr that exists in obj\nclass GetAttrBase Basic delegation of __getattr__ and __dir__\n\ndef __getattr__(self, k)\ndef __dir__(self)\n\nclass GetAttr Inherit from this to have all attr accesses in self._xtra passed down to self.default\n\ndef __getattr__(self, k)\ndef __dir__(self)\ndef __setstate__(self, data)\n\ndef delegate_attr(self, k, to) Use in __getattr__ to delegate to attr to without inheriting from GetAttr\nclass ShowPrint Base class that prints for show\n\ndef show(self, *args, **kwargs)\n\nclass Int An extensible int\nclass Str An extensible str\nclass Float An extensible float\ndef partition(coll, f) Partition a collection by a predicate\ndef flatten(o) Concatenate all collections and items as a generator\ndef concat(colls) Concatenate all collections and items as a list\ndef strcat(its, sep) Concatenate stringified items its\ndef detuplify(x) If x is a tuple with one thing, extract it\ndef replicate(item, match) Create tuple of item copied len(match) times\ndef setify(o) Turn any list like-object into a set.\ndef merge(*ds) Merge all dictionaries in ds\ndef range_of(x) All indices of collection x (i.e. list(range(len(x))))\ndef groupby(x, key, val) Like itertools.groupby but doesn’t need to be sorted, and isn’t lazy, plus some extensions\ndef last_index(x, o) Finds the last index of occurence of x in o (returns -1 if no occurence)\ndef filter_dict(d, func) Filter a dict using func, applied to keys and values\ndef filter_keys(d, func) Filter a dict using func, applied to keys\ndef filter_values(d, func) Filter a dict using func, applied to values\ndef cycle(o) Like itertools.cycle except creates list of Nones if o is empty\ndef zip_cycle(x, *args) Like itertools.zip_longest but cycles through elements of all but first argument\ndef sorted_ex(iterable, key, reverse) Like sorted, but if key is str use attrgetter; if int use itemgetter\ndef not_(f) Create new function that negates result of f\ndef argwhere(iterable, f, negate, **kwargs) Like filter_ex, but return indices for matching items\ndef filter_ex(iterable, f, negate, gen, **kwargs) Like filter, but passing kwargs to f, defaulting f to noop, and adding negate and gen\ndef renumerate(iterable, start) Same as enumerate, but returns index as 2nd element instead of 1st\ndef first(x, f, negate, **kwargs) First element of x, optionally filtered by f, or None if missing\ndef only(o) Return the only item of o, raise if o doesn’t have exactly one item\ndef nested_attr(o, attr, default) Same as getattr, but if attr includes a ., then looks inside nested objects\ndef nested_setdefault(o, attr, default) Same as setdefault, but if attr includes a ., then looks inside nested objects\ndef nested_callable(o, attr) Same as nested_attr but if not found will return noop\ndef nested_idx(coll, *idxs) Index into nested collections, dicts, etc, with idxs\ndef set_nested_idx(coll, value, *idxs) Set value indexed like `nested_idx\ndef val2idx(x) Dict from value to index\ndef uniqueify(x, sort, bidir, start) Unique elements in x, optional sort, optional return reverse correspondence, optional prepend with elements.\ndef loop_first_last(values) Iterate and generate a tuple with a flag for first and last value.\ndef loop_first(values) Iterate and generate a tuple with a flag for first value.\ndef loop_last(values) Iterate and generate a tuple with a flag for last value.\ndef first_match(lst, f, default) First element of lst matching predicate f, or default if none\ndef last_match(lst, f, default) Last element of lst matching predicate f, or default if none\nclass fastuple A tuple with elementwise ops and more friendly init behavior\n\ndef __new__(cls, x, *rest)\ndef mul(self, *args) * is already defined in tuple for replicating, so use mul instead\ndef add(self, *args) + is already defined in tuple for concat, so use add instead\n\nclass bind Same as partial, except you can use arg0 arg1 etc param placeholders\n\ndef __init__(self, func, *pargs, **pkwargs)\ndef __call__(self, *args, **kwargs)\n\ndef mapt(func, *iterables) Tuplified map\ndef map_ex(iterable, f, *args, **kwargs) Like map, but use bind, and supports str and indexing\ndef compose(*funcs) Create a function that composes all functions in funcs, passing along remaining *args and **kwargs to all\ndef maps(*args) Like map, except funcs are composed first\ndef partialler(f, *args, **kwargs) Like functools.partial but also copies over docstring\ndef instantiate(t) Instantiate t if it’s a type, otherwise do nothing\ndef using_attr(f, attr) Construct a function which applies f to the argument’s attribute attr\ndef copy_func(f) Copy a non-builtin function (NB copy.copy does not work for this)\ndef patch_to(cls, as_prop, cls_method) Decorator: add f to cls\ndef patch(f) Decorator: add f to the first parameter’s class (based on f’s type annotations)\ndef patch_property(f) Deprecated; use patch(as_prop=True) instead\ndef compile_re(pat) Compile pat if it’s not None\nclass ImportEnum An Enum that can have its values imported\n\n@classmethod def imports(cls)\n@property def name(self)\n\nclass StrEnum An ImportEnum that behaves like a str\n\ndef __str__(self)\n@property def name(self)\n\ndef str_enum(name, *vals) Simplified creation of StrEnum types\nclass ValEnum An ImportEnum that stringifies using values\n\ndef __str__(self)\n@property def name(self)\n\nclass Stateful A base class/mixin for objects that should not serialize all their state\n\ndef __init__(self, *args, **kwargs)\ndef __getstate__(self)\ndef __setstate__(self, state)\n\nclass NotStr Behaves like a str, but isn’t an instance of one\n\ndef __init__(self, s)\ndef __repr__(self)\ndef __str__(self)\ndef __add__(self, b)\ndef __mul__(self, b)\ndef __len__(self)\ndef __eq__(self, b)\ndef __lt__(self, b)\ndef __hash__(self)\ndef __bool__(self)\ndef __contains__(self, b)\ndef __iter__(self)\n\nclass PrettyString Little hack to get strings to show properly in Jupyter.\n\ndef __repr__(self)\n\ndef even_mults(start, stop, n) Build log-stepped array from start to stop in n steps.\ndef num_cpus() Get number of cpus\ndef add_props(f, g, n) Create properties passing each of range(n) to f\ndef typed(f) Decorator to check param and return types at runtime\ndef exec_new(code) Execute code in a new environment and return it\ndef exec_import(mod, sym) Import sym from mod in a new environment\ndef str2bool(s) Case-insensitive convert string s too a bool (y,yes,t,true,on,1-&gt;True)\n\n\n\n\n\nBasic single and dual parameter dispatch\n\n\ndef lenient_issubclass(cls, types) If possible return whether cls is a subclass of types, otherwise return False.\ndef sorted_topologically(iterable) Return a new list containing all items from the iterable sorted topologically\nclass TypeDispatch Dictionary-like object; __getitem__ matches keys of types using issubclass\n\ndef __init__(self, funcs, bases)\ndef add(self, f) Add type t and function f\ndef first(self) Get first function in ordered dict of type:func.\ndef returns(self, x) Get the return type of annotation of x.\ndef __repr__(self)\ndef __call__(self, *args, **kwargs)\ndef __get__(self, inst, owner)\ndef __getitem__(self, k) Find first matching type that is a super-class of k\n\nclass DispatchReg A global registry for TypeDispatch objects keyed by function name\n\ndef __init__(self)\ndef __call__(self, f)\n\ndef retain_meta(x, res, as_copy) Call res.set_meta(x), if it exists\ndef default_set_meta(self, x, as_copy) Copy over _meta from x to res, if it’s missing\n@typedispatch def cast(x, typ) cast x to type typ (may also change x inplace)\ndef retain_type(new, old, typ, as_copy) Cast new to type of old or typ if it’s a superclass\ndef retain_types(new, old, typs) Cast each item of new to type of matching item in old if it’s a superclass\ndef explode_types(o) Return the type of o, potentially in nested dictionaries for thing that are listy\n\n\n\n\n\nDocument parameters using comments.\n\n\ndef docstring(sym) Get docstring for sym for functions ad classes\ndef parse_docstring(sym) Parse a numpy-style docstring in sym\ndef isdataclass(s) Check if s is a dataclass but not a dataclass’ instance\ndef get_dataclass_source(s) Get source code for dataclass s\ndef get_source(s) Get source code for string, function object or dataclass s\ndef get_name(obj) Get the name of obj\ndef qual_name(obj) Get the qualified name of obj\n@delegates(_docments) def docments(elt, full, **kwargs) Generates a docment\ndef extract_docstrings(code) Create a dict from function/class/method names to tuples of docstrings and param lists\n\n\n\n\n\nParse numpy-style docstrings\n\n\ndef strip_blank_lines(l) Remove leading and trailing blank lines from a list of lines\nclass Reader A line-based string reader.\n\ndef __init__(self, data)\ndef __getitem__(self, n)\ndef reset(self)\ndef read(self)\ndef seek_next_non_empty_line(self)\ndef eof(self)\ndef read_to_condition(self, condition_func)\ndef read_to_next_empty_line(self)\ndef read_to_next_unindented_line(self)\ndef peek(self, n)\ndef is_empty(self)\n\nclass ParseError\n\ndef __str__(self)\n\nclass NumpyDocString Parses a numpydoc string to an abstract representation\n\ndef __init__(self, docstring, config)\ndef __iter__(self)\ndef __len__(self)\ndef __getitem__(self, key)\ndef __setitem__(self, key, val)\n\ndef dedent_lines(lines, split) Deindent a list of lines maximally\n\n\n\n\n\nThe L class and helpers for it\n\n\n@contextmanager def working_directory(path) Change working directory to path and return to previous on exit.\ndef add_docs(cls, cls_doc, **docs) Copy values from docs to cls docstrings, and confirm all public methods are documented\ndef docs(cls) Decorator version of add_docs, using _docs dict\ndef coll_repr(c, max_n) String repr of up to max_n items of (possibly lazy) collection c\ndef is_bool(x) Check whether x is a bool or None\ndef mask2idxs(mask) Convert bool mask or index list to index L\ndef is_indexer(idx) Test whether idx will index a single item in a list\nclass CollBase Base class for composing a list of items\n\ndef __init__(self, items)\ndef __len__(self)\ndef __getitem__(self, k)\ndef __setitem__(self, k, v)\ndef __delitem__(self, i)\ndef __repr__(self)\ndef __iter__(self)\n\nclass L Behaves like a list of items but can also index with list of indices or masks\n\ndef __init__(self, items, *rest)\ndef __getitem__(self, idx)\ndef copy(self)\ndef __setitem__(self, idx, o) Set idx (can be list of indices, or mask, or int) items to o (which is broadcast if not iterable)\ndef __eq__(self, b)\ndef sorted(self, key, reverse)\ndef __iter__(self)\ndef __contains__(self, b)\ndef __reversed__(self)\ndef __invert__(self)\ndef __repr__(self)\ndef __mul__(a, b)\ndef __add__(a, b)\ndef __radd__(a, b)\ndef __addi__(a, b)\n@classmethod def split(cls, s, sep, maxsplit)\n@classmethod def range(cls, a, b, step)\ndef map(self, f, *args, **kwargs)\ndef argwhere(self, f, negate, **kwargs)\ndef argfirst(self, f, negate)\ndef filter(self, f, negate, **kwargs)\ndef enumerate(self)\ndef renumerate(self)\ndef unique(self, sort, bidir, start)\ndef val2idx(self)\ndef cycle(self)\ndef map_dict(self, f, *args, **kwargs)\ndef map_first(self, f, g, *args, **kwargs)\ndef itemgot(self, *idxs)\ndef attrgot(self, k, default)\ndef starmap(self, f, *args, **kwargs)\ndef zip(self, cycled)\ndef zipwith(self, *rest)\ndef map_zip(self, f, *args, **kwargs)\ndef map_zipwith(self, f, *rest, **kwargs)\ndef shuffle(self)\ndef concat(self)\ndef reduce(self, f, initial)\ndef sum(self)\ndef product(self)\ndef setattrs(self, attr, val)\n\ndef save_config_file(file, d, **kwargs) Write settings dict to a new config file, or overwrite the existing one.\nclass Config Reading and writing ConfigParser ini files\n\ndef __init__(self, cfg_path, cfg_name, create, save, extra_files, types)\ndef __repr__(self)\ndef __setitem__(self, k, v)\ndef __contains__(self, k)\ndef save(self)\ndef __getattr__(self, k)\ndef __getitem__(self, k)\ndef get(self, k, default)\ndef path(self, k, default)\n\n\n\n\n\n\nRecognize image file formats based on their first few bytes.\n\n\ndef test_jpeg(h, f) JPEG data with JFIF or Exif markers; and raw JPEG\ndef test_gif(h, f) GIF (’87 and ’89 variants)\ndef test_tiff(h, f) TIFF (can be in Motorola or Intel byte order)\ndef test_rgb(h, f) SGI image library\ndef test_pbm(h, f) PBM (portable bitmap)\ndef test_pgm(h, f) PGM (portable graymap)\ndef test_ppm(h, f) PPM (portable pixmap)\ndef test_rast(h, f) Sun raster file\ndef test_xbm(h, f) X bitmap (X10 or X11)\n\n\n\n\n\ndef is_iter(o) Test whether o can be used in a for loop\ndef is_coll(o) Test whether o is a collection (i.e. has a usable len)\ndef all_equal(a, b) Compares whether a and b are the same length and have the same contents\ndef noop(x, *args, **kwargs) Do nothing\ndef noops(self, x, *args, **kwargs) Do nothing (method)\ndef isinstance_str(x, cls_name) Like isinstance, except takes a type name instead of a type\ndef equals(a, b) Compares a and b for equality; supports sublists, tensors and arrays too\ndef ipython_shell() Same as get_ipython but returns False if not in IPython\ndef in_ipython() Check if code is running in some kind of IPython environment\ndef in_colab() Check if the code is running in Google Colaboratory\ndef in_jupyter() Check if the code is running in a jupyter notebook\ndef in_notebook() Check if the code is running in a jupyter notebook\ndef remove_prefix(text, prefix) Temporary until py39 is a prereq\ndef remove_suffix(text, suffix) Temporary until py39 is a prereq\n\n\n\n\n\nMetaclasses\n\n\ndef test_sig(f, b) Test the signature of an object\nclass FixSigMeta A metaclass that fixes the signature on classes that override __new__\n\ndef __new__(cls, name, bases, dict)\n\nclass PrePostInitMeta A metaclass that calls optional __pre_init__ and __post_init__ methods\n\ndef __call__(cls, *args, **kwargs)\n\nclass AutoInit Same as object, but no need for subclasses to call super().__init__\n\ndef __pre_init__(self, *args, **kwargs)\n\nclass NewChkMeta Metaclass to avoid recreating object passed to constructor\n\ndef __call__(cls, x, *args, **kwargs)\n\nclass BypassNewMeta Metaclass: casts x to this class if it’s of type cls._bypass_type\n\ndef __call__(cls, x, *args, **kwargs)\n\ndef empty2none(p) Replace Parameter.empty with None\ndef anno_dict(f) __annotation__ dictionary withemptycast toNone`, returning empty if doesn’t exist\ndef use_kwargs_dict(keep, **kwargs) Decorator: replace **kwargs in signature with names params\ndef use_kwargs(names, keep) Decorator: replace **kwargs in signature with names params\ndef delegates(to, keep, but) Decorator: replace **kwargs in signature with params from to\ndef method(f) Mark f as a method\ndef funcs_kwargs(as_method) Replace methods in cls._methods with those from kwargs\n\n\n\n\n\nNetwork, HTTP, and URL functions\n\n\ndef urlquote(url) Update url’s path with urllib.parse.quote\ndef urlwrap(url, data, headers) Wrap url in a urllib Request with urlquote\nclass HTTP4xxClientError Base class for client exceptions (code 4xx) from url* functions\nclass HTTP5xxServerError Base class for server exceptions (code 5xx) from url* functions\ndef urlopen(url, data, headers, timeout, **kwargs) Like urllib.request.urlopen, but first urlwrap the url, and encode data\ndef urlread(url, data, headers, decode, return_json, return_headers, timeout, **kwargs) Retrieve url, using data dict or kwargs to POST if present\ndef urljson(url, data, timeout) Retrieve url and decode json\ndef urlclean(url) Remove fragment, params, and querystring from url if present\ndef urlsave(url, dest, reporthook, headers, timeout) Retrieve url and save based on its name\ndef urlvalid(x) Test if x is a valid URL\ndef urlrequest(url, verb, headers, route, query, data, json_data) Request for url with optional route params replaced by route, plus query string, and post data\n@patch def summary(self, skip) Summary containing full_url, headers, method, and data, removing skip from headers\ndef urlsend(url, verb, headers, decode, route, query, data, json_data, return_json, return_headers, debug, timeout) Send request with urlrequest, converting result to json if return_json\ndef do_request(url, post, headers, **data) Call GET or json-encoded POST on url, depending on post\ndef start_server(port, host, dgram, reuse_addr, n_queue) Create a socket server on port, with optional host, of type dgram\ndef start_client(port, host, dgram) Create a socket client on port, with optional host, of type dgram\ndef tobytes(s) Convert s into HTTP-ready bytes format\ndef http_response(body, status, hdrs, **kwargs) Create an HTTP-ready response, adding kwargs to hdrs\n@threaded def recv_once(host, port) Spawn a thread to receive a single HTTP request and store in d['r']\n\n\n\n\n\nThreading and multiprocessing functions\n\n\ndef threaded(process) Run f in a Thread (or Process if process=True), and returns it\ndef startthread(f) Like threaded, but start thread immediately\ndef startproc(f) Like threaded(True), but start Process immediately\nclass ThreadPoolExecutor Same as Python’s ThreadPoolExecutor, except can pass max_workers==0 for serial execution\n\ndef __init__(self, max_workers, on_exc, pause, **kwargs)\ndef map(self, f, items, *args, **kwargs)\n\n@delegates() class ProcessPoolExecutor Same as Python’s ProcessPoolExecutor, except can pass max_workers==0 for serial execution\n\ndef __init__(self, max_workers, on_exc, pause, **kwargs)\ndef map(self, f, items, *args, **kwargs)\n\ndef parallel(f, items, *args, **kwargs) Applies func in parallel to items, using n_workers\ndef run_procs(f, f_done, args) Call f for each item in args in parallel, yielding f_done\ndef parallel_gen(cls, items, n_workers, **kwargs) Instantiate cls in n_workers procs & call each on a subset of items in parallel.\n\n\n\n\n\ndef imp_mod(module_path, package) Import dynamically the module referenced in fn\ndef has_deco(node, name) Check if a function node node has a decorator named name\ndef create_pyi(fn, package) Convert fname.py to fname.pyi by removing function bodies and expanding delegates kwargs\n@call_parse def py2pyi(fname, package) Convert fname.py to fname.pyi by removing function bodies and expanding delegates kwargs\n@call_parse def replace_wildcards(path) Expand wildcard imports in the specified Python file.\n\n\n\n\n\nA fast way to turn your python function into a script.\n\n\ndef store_true() Placeholder to pass to Param for store_true action\ndef store_false() Placeholder to pass to Param for store_false action\ndef bool_arg(v) Use as type for Param to get bool behavior\nclass Param A parameter in a function used in anno_parser or call_parse\n\ndef __init__(self, help, type, opt, action, nargs, const, choices, required, default)\ndef set_default(self, d)\n@property def pre(self)\n@property def kwargs(self)\ndef __repr__(self)\n\ndef anno_parser(func, prog) Look at params (annotated with Param) in func and return an ArgumentParser\ndef args_from_prog(func, prog) Extract args from prog\ndef call_parse(func, nested) Decorator to create a simple CLI from func using anno_parser\n\n\n\n\n\nFast styling for friendly CLIs.\n\n\nclass StyleCode An escape sequence for styling terminal text.\n\ndef __init__(self, name, code, typ)\ndef __str__(self)\n\nclass Style A minimal terminal text styler.\n\ndef __init__(self, codes)\ndef __dir__(self)\ndef __getattr__(self, k)\ndef __call__(self, obj)\ndef __repr__(self)\n\ndef demo() Demonstrate all available styles and their codes.\n\n\n\n\n\nHelper functions to quickly write tests in notebooks\n\n\ndef test_fail(f, msg, contains, args, kwargs) Fails with msg unless f() raises an exception and (optionally) has contains in e.args\ndef test(a, b, cmp, cname) assert that cmp(a,b); display inputs and cname or cmp.__name__ if it fails\ndef nequals(a, b) Compares a and b for not equals\ndef test_eq(a, b) test that a==b\ndef test_eq_type(a, b) test that a==b and are same type\ndef test_ne(a, b) test that a!=b\ndef is_close(a, b, eps) Is a within eps of b\ndef test_close(a, b, eps) test that a is within eps of b\ndef test_is(a, b) test that a is b\ndef test_shuffled(a, b) test that a and b are shuffled versions of the same sequence of items\ndef test_stdout(f, exp, regex) Test that f prints exp to stdout, optionally checking as regex\ndef test_fig_exists(ax) Test there is a figure displayed in ax\nclass ExceptionExpected Context manager that tests if an exception is raised\n\ndef __init__(self, ex, regex)\ndef __enter__(self)\ndef __exit__(self, type, value, traceback)\n\n\n\n\n\n\nDefinition of Transform and Pipeline\n\n\nclass Transform Delegates (__call__,decode,setup) to (encodes,decodes,setups) if split_idx matches\n\ndef __init__(self, enc, dec, split_idx, order)\n@property def name(self)\ndef __call__(self, x, **kwargs)\ndef decode(self, x, **kwargs)\ndef __repr__(self)\ndef setup(self, items, train_setup)\n\nclass InplaceTransform A Transform that modifies in-place and just returns whatever it’s passed\nclass DisplayedTransform A transform with a __repr__ that shows its attrs\n\n@property def name(self)\n\nclass ItemTransform A transform that always take tuples as items\n\ndef __call__(self, x, **kwargs)\ndef decode(self, x, **kwargs)\n\ndef get_func(t, name, *args, **kwargs) Get the t.name (potentially partial-ized with args and kwargs) or noop if not defined\nclass Func Basic wrapper around a name with args and kwargs to call on a given type\n\ndef __init__(self, name, *args, **kwargs)\ndef __repr__(self)\ndef __call__(self, t)\n\ndef compose_tfms(x, tfms, is_enc, reverse, **kwargs) Apply all func_nm attribute of tfms on x, maybe in reverse order\ndef mk_transform(f) Convert function f to Transform if it isn’t already one\ndef gather_attrs(o, k, nm) Used in getattr to collect all attrs k from self.{nm}\ndef gather_attr_names(o, nm) Used in dir to collect all attrs k from self.{nm}\nclass Pipeline A pipeline of composed (for encode/decode) transforms, setup with types\n\ndef __init__(self, funcs, split_idx)\ndef setup(self, items, train_setup)\ndef add(self, ts, items, train_setup)\ndef __call__(self, o)\ndef __repr__(self)\ndef __getitem__(self, i)\ndef __setstate__(self, data)\ndef __getattr__(self, k)\ndef __dir__(self)\ndef decode(self, o, full)\ndef show(self, o, ctx, **kwargs)\n\n\n\n\n\n\nXDG Base Directory Specification helpers.\n\n\ndef xdg_cache_home() Path corresponding to XDG_CACHE_HOME\ndef xdg_config_dirs() Paths corresponding to XDG_CONFIG_DIRS\ndef xdg_config_home() Path corresponding to XDG_CONFIG_HOME\ndef xdg_data_dirs() Paths corresponding to XDG_DATA_DIRS`\ndef xdg_data_home() Path corresponding to XDG_DATA_HOME\ndef xdg_runtime_dir() Path corresponding to XDG_RUNTIME_DIR\ndef xdg_state_home() Path corresponding to XDG_STATE_HOME\n\n\n\n\n\nConcise generation of XML.\n\n\nclass FT A ‘Fast Tag’ structure, containing tag,children,and attrs\n\ndef __init__(self, tag, cs, attrs, void_, **kwargs)\ndef __setattr__(self, k, v)\ndef __getattr__(self, k)\n@property def list(self)\ndef get(self, k, default)\ndef __repr__(self)\ndef __add__(self, b)\ndef __getitem__(self, idx)\ndef __iter__(self)\n\ndef ft(tag, *c, **kw) Create an FT structure for to_xml()\ndef Html(*c, **kwargs) An HTML tag, optionally preceeded by !DOCTYPE HTML\nclass Safe\n\ndef __html__(self)\n\ndef to_xml(elm, lvl, indent, do_escape) Convert ft element tree into an XML string\ndef highlight(s, lang) Markdown to syntax-highlight s in language lang\n\n\n\n\n\nUtility functions used in the fastai library\n\n\ndef walk(path, symlinks, keep_file, keep_folder, skip_folder, func, ret_folders) Generator version of os.walk, using functions to filter files and folders\ndef globtastic(path, recursive, symlinks, file_glob, file_re, folder_re, skip_file_glob, skip_file_re, skip_folder_re, func, ret_folders) A more powerful glob, including regex matches, symlink handling, and skip parameters\n@contextmanager def maybe_open(f, mode, **kwargs) Context manager: open f if it is a path (and close on exit)\ndef mkdir(path, exist_ok, parents, overwrite, **kwargs) Creates and returns a directory defined by path, optionally removing previous existing directory if overwrite is True\ndef image_size(fn) Tuple of (w,h) for png, gif, or jpg; None otherwise\ndef bunzip(fn) bunzip fn, raising exception if output already exists\ndef loads(s, **kw) Same as json.loads, but handles None\ndef loads_multi(s) Generator of &gt;=0 decoded json dicts, possibly with non-json ignored text at start and end\ndef dumps(obj, **kw) Same as json.dumps, but uses ujson if available\ndef untar_dir(fname, dest, rename, overwrite) untar file into dest, creating a directory if the root contains more than one item\ndef repo_details(url) Tuple of owner,name from ssh or https git repo url\ndef run(cmd, *rest) Pass cmd (splitting with shlex if string) to subprocess.run; return stdout; raise IOError if fails\ndef open_file(fn, mode, **kwargs) Open a file, with optional compression if gz or bz2 suffix\ndef save_pickle(fn, o) Save a pickle file, to a file name or opened file\ndef load_pickle(fn) Load a pickle file from a file name or opened file\ndef parse_env(s, fn) Parse a shell-style environment string or file\ndef expand_wildcards(code) Expand all wildcard imports in the given code string.\ndef dict2obj(d, list_func, dict_func) Convert (possibly nested) dicts (or lists of dicts) to AttrDict\ndef obj2dict(d) Convert (possibly nested) AttrDicts (or lists of AttrDicts) to dict\ndef repr_dict(d) Print nested dicts and lists, such as returned by dict2obj\ndef is_listy(x) isinstance(x, (tuple,list,L,slice,Generator))\ndef mapped(f, it) map f over it, unless it’s not listy, in which case return f(it)\n@patch def readlines(self, hint, encoding) Read the content of self\n@patch def read_json(self, encoding, errors) Same as read_text followed by loads\n@patch def mk_write(self, data, encoding, errors, mode) Make all parent dirs of self, and write data\n@patch def relpath(self, start) Same as os.path.relpath, but returns a Path, and resolves symlinks\n@patch def ls(self, n_max, file_type, file_exts) Contents of path as a list\n@patch def delete(self) Delete a file, symlink, or directory tree\nclass IterLen Base class to add iteration to anything supporting __len__ and __getitem__\n\ndef __iter__(self)\n\n@docs class ReindexCollection Reindexes collection coll with indices idxs and optional LRU cache of size cache\n\ndef __init__(self, coll, idxs, cache, tfm)\ndef __getitem__(self, i)\ndef __len__(self)\ndef reindex(self, idxs)\ndef shuffle(self)\ndef cache_clear(self)\ndef __getstate__(self)\ndef __setstate__(self, s)\n\ndef get_source_link(func) Return link to func in source code\ndef truncstr(s, maxlen, suf, space) Truncate s to length maxlen, adding suffix suf if truncated\ndef sparkline(data, mn, mx, empty_zero) Sparkline for data, with Nones (and zero, if empty_zero) shown as empty column\ndef modify_exception(e, msg, replace) Modifies e with a custom message attached\ndef round_multiple(x, mult, round_down) Round x to nearest multiple of mult\ndef set_num_threads(nt) Get numpy (and others) to use nt threads\ndef join_path_file(file, path, ext) Return path/file if file is a string or a Path, file otherwise\ndef autostart(g) Decorator that automatically starts a generator\nclass EventTimer An event timer with history of store items of time span\n\ndef __init__(self, store, span)\ndef add(self, n) Record n events\n@property def duration(self)\n@property def freq(self)\n\ndef stringfmt_names(s) Unique brace-delimited names in s\nclass PartialFormatter A string.Formatter that doesn’t error on missing fields, and tracks missing fields and unused args\n\ndef __init__(self)\ndef get_field(self, nm, args, kwargs)\ndef check_unused_args(self, used, args, kwargs)\n\ndef partial_format(s, **kwargs) string format s, ignoring missing field errors, returning missing and extra fields\ndef utc2local(dt) Convert dt from UTC to local time\ndef local2utc(dt) Convert dt from local to UTC time\ndef trace(f) Add set_trace to an existing function f\n@contextmanager def modified_env(*delete, **replace) Context manager temporarily modifying os.environ by deleting delete and replacing replace\nclass ContextManagers Wrapper for contextlib.ExitStack which enters a collection of context managers\n\ndef __init__(self, mgrs)\ndef __enter__(self)\ndef __exit__(self, *args, **kwargs)\n\ndef shufflish(x, pct) Randomly relocate items of x up to pct of len(x) from their starting location\ndef console_help(libname) Show help for all console scripts from libname\ndef hl_md(s, lang, show) Syntax highlight s using lang.\ndef type2str(typ) Stringify typ\nclass Unset\n\ndef __repr__(self)\ndef __str__(self)\ndef __bool__(self)\n@property def name(self)\n\ndef nullable_dc(cls) Like dataclass, but default of UNSET added to fields without defaults\ndef flexiclass(cls) Convert cls into a dataclass like make_nullable. Converts in place and also returns the result.\ndef asdict(o) Convert o to a dict, supporting dataclasses, namedtuples, iterables, and __dict__ attrs.\ndef is_typeddict(cls) Check if cls is a TypedDict\ndef is_namedtuple(cls) True if cls is a namedtuple type\ndef flexicache(*funcs) Like lru_cache, but customisable with policy funcs\ndef time_policy(seconds) A flexicache policy that expires cached items after seconds have passed\ndef mtime_policy(filepath) A flexicache policy that expires cached items after filepath modified-time changes\ndef timed_cache(seconds, maxsize) Like lru_cache, but also with time-based eviction"
  },
  {
    "objectID": "filelist.html#fastcore.basics",
    "href": "filelist.html#fastcore.basics",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "Basic functionality used in the fastai library\n\n\ndef ifnone(a, b) b if a is None else a\ndef maybe_attr(o, attr) getattr(o,attr,o)\ndef basic_repr(flds) Minimal __repr__\ndef is_array(x) True if x supports __array__ or iloc\ndef listify(o, *rest) Convert o to a list\ndef tuplify(o, use_list, match) Make o a tuple\ndef true(x) Test whether x is truthy; collections with &gt;0 elements are considered True\nclass NullType An object that is False and can be called, chained, and indexed\n\ndef __getattr__(self, *args)\ndef __call__(self, *args, **kwargs)\ndef __getitem__(self, *args)\ndef __bool__(self)\n\ndef tonull(x) Convert None to null\ndef get_class(nm, *fld_names, **flds) Dynamically create a class, optionally inheriting from sup, containing fld_names\ndef mk_class(nm, *fld_names, **flds) Create a class using get_class and add to the caller’s module\ndef wrap_class(nm, *fld_names, **flds) Decorator: makes function a method of a new class nm passing parameters to mk_class\nclass ignore_exceptions Context manager to ignore exceptions\n\ndef __enter__(self)\ndef __exit__(self, *args)\n\ndef exec_local(code, var_name) Call exec on code and return the var var_name\ndef risinstance(types, obj) Curried isinstance but with args reversed\nclass Inf Infinite lists\ndef in_(x, a) True if x in a\ndef ret_true(*args, **kwargs) Predicate: always True\ndef ret_false(*args, **kwargs) Predicate: always False\ndef stop(e) Raises exception e (by default StopIteration)\ndef gen(func, seq, cond) Like (func(o) for o in seq if cond(func(o))) but handles StopIteration\ndef chunked(it, chunk_sz, drop_last, n_chunks) Return batches from iterator it of size chunk_sz (or return n_chunks total)\ndef otherwise(x, tst, y) y if tst(x) else x\ndef custom_dir(c, add) Implement custom __dir__, adding add to cls\nclass AttrDict dict subclass that also provides access to keys as attrs\n\ndef __getattr__(self, k)\ndef __setattr__(self, k, v)\ndef __dir__(self)\ndef copy(self)\n\nclass AttrDictDefault AttrDict subclass that returns None for missing attrs\n\ndef __init__(self, *args, **kwargs)\ndef __getattr__(self, k)\n\nclass NS SimpleNamespace subclass that also adds iter and dict support\n\ndef __iter__(self)\ndef __getitem__(self, x)\ndef __setitem__(self, x, y)\n\ndef get_annotations_ex(obj) Backport of py3.10 get_annotations that returns globals/locals\ndef eval_type(t, glb, loc) eval a type or collection of types, if needed, for annotations in py3.10+\ndef type_hints(f) Like typing.get_type_hints but returns {} if not allowed type\ndef annotations(o) Annotations for o, or type(o)\ndef anno_ret(func) Get the return annotation of func\ndef signature_ex(obj, eval_str) Backport of inspect.signature(..., eval_str=True to &lt;py310\ndef argnames(f, frame) Names of arguments to function or frame f\ndef with_cast(f) Decorator which uses any parameter annotations as preprocessing functions\ndef store_attr(names, self, but, cast, store_args, **attrs) Store params named in comma-separated names from calling context into attrs in self\ndef attrdict(o, *ks) Dict from each k in ks to getattr(o,k)\ndef properties(cls, *ps) Change attrs in cls with names in ps to properties\ndef camel2words(s, space) Convert CamelCase to ‘spaced words’\ndef camel2snake(name) Convert CamelCase to snake_case\ndef snake2camel(s) Convert snake_case to CamelCase\ndef class2attr(self, cls_name) Return the snake-cased name of the class; strip ending cls_name if it exists.\ndef getcallable(o, attr) Calls getattr with a default of noop\ndef getattrs(o, *attrs) List of all attrs in o\ndef hasattrs(o, attrs) Test whether o contains all attrs\ndef try_attrs(obj, *attrs) Return first attr that exists in obj\nclass GetAttrBase Basic delegation of __getattr__ and __dir__\n\ndef __getattr__(self, k)\ndef __dir__(self)\n\nclass GetAttr Inherit from this to have all attr accesses in self._xtra passed down to self.default\n\ndef __getattr__(self, k)\ndef __dir__(self)\ndef __setstate__(self, data)\n\ndef delegate_attr(self, k, to) Use in __getattr__ to delegate to attr to without inheriting from GetAttr\nclass ShowPrint Base class that prints for show\n\ndef show(self, *args, **kwargs)\n\nclass Int An extensible int\nclass Str An extensible str\nclass Float An extensible float\ndef partition(coll, f) Partition a collection by a predicate\ndef flatten(o) Concatenate all collections and items as a generator\ndef concat(colls) Concatenate all collections and items as a list\ndef strcat(its, sep) Concatenate stringified items its\ndef detuplify(x) If x is a tuple with one thing, extract it\ndef replicate(item, match) Create tuple of item copied len(match) times\ndef setify(o) Turn any list like-object into a set.\ndef merge(*ds) Merge all dictionaries in ds\ndef range_of(x) All indices of collection x (i.e. list(range(len(x))))\ndef groupby(x, key, val) Like itertools.groupby but doesn’t need to be sorted, and isn’t lazy, plus some extensions\ndef last_index(x, o) Finds the last index of occurence of x in o (returns -1 if no occurence)\ndef filter_dict(d, func) Filter a dict using func, applied to keys and values\ndef filter_keys(d, func) Filter a dict using func, applied to keys\ndef filter_values(d, func) Filter a dict using func, applied to values\ndef cycle(o) Like itertools.cycle except creates list of Nones if o is empty\ndef zip_cycle(x, *args) Like itertools.zip_longest but cycles through elements of all but first argument\ndef sorted_ex(iterable, key, reverse) Like sorted, but if key is str use attrgetter; if int use itemgetter\ndef not_(f) Create new function that negates result of f\ndef argwhere(iterable, f, negate, **kwargs) Like filter_ex, but return indices for matching items\ndef filter_ex(iterable, f, negate, gen, **kwargs) Like filter, but passing kwargs to f, defaulting f to noop, and adding negate and gen\ndef renumerate(iterable, start) Same as enumerate, but returns index as 2nd element instead of 1st\ndef first(x, f, negate, **kwargs) First element of x, optionally filtered by f, or None if missing\ndef only(o) Return the only item of o, raise if o doesn’t have exactly one item\ndef nested_attr(o, attr, default) Same as getattr, but if attr includes a ., then looks inside nested objects\ndef nested_setdefault(o, attr, default) Same as setdefault, but if attr includes a ., then looks inside nested objects\ndef nested_callable(o, attr) Same as nested_attr but if not found will return noop\ndef nested_idx(coll, *idxs) Index into nested collections, dicts, etc, with idxs\ndef set_nested_idx(coll, value, *idxs) Set value indexed like `nested_idx\ndef val2idx(x) Dict from value to index\ndef uniqueify(x, sort, bidir, start) Unique elements in x, optional sort, optional return reverse correspondence, optional prepend with elements.\ndef loop_first_last(values) Iterate and generate a tuple with a flag for first and last value.\ndef loop_first(values) Iterate and generate a tuple with a flag for first value.\ndef loop_last(values) Iterate and generate a tuple with a flag for last value.\ndef first_match(lst, f, default) First element of lst matching predicate f, or default if none\ndef last_match(lst, f, default) Last element of lst matching predicate f, or default if none\nclass fastuple A tuple with elementwise ops and more friendly init behavior\n\ndef __new__(cls, x, *rest)\ndef mul(self, *args) * is already defined in tuple for replicating, so use mul instead\ndef add(self, *args) + is already defined in tuple for concat, so use add instead\n\nclass bind Same as partial, except you can use arg0 arg1 etc param placeholders\n\ndef __init__(self, func, *pargs, **pkwargs)\ndef __call__(self, *args, **kwargs)\n\ndef mapt(func, *iterables) Tuplified map\ndef map_ex(iterable, f, *args, **kwargs) Like map, but use bind, and supports str and indexing\ndef compose(*funcs) Create a function that composes all functions in funcs, passing along remaining *args and **kwargs to all\ndef maps(*args) Like map, except funcs are composed first\ndef partialler(f, *args, **kwargs) Like functools.partial but also copies over docstring\ndef instantiate(t) Instantiate t if it’s a type, otherwise do nothing\ndef using_attr(f, attr) Construct a function which applies f to the argument’s attribute attr\ndef copy_func(f) Copy a non-builtin function (NB copy.copy does not work for this)\ndef patch_to(cls, as_prop, cls_method) Decorator: add f to cls\ndef patch(f) Decorator: add f to the first parameter’s class (based on f’s type annotations)\ndef patch_property(f) Deprecated; use patch(as_prop=True) instead\ndef compile_re(pat) Compile pat if it’s not None\nclass ImportEnum An Enum that can have its values imported\n\n@classmethod def imports(cls)\n@property def name(self)\n\nclass StrEnum An ImportEnum that behaves like a str\n\ndef __str__(self)\n@property def name(self)\n\ndef str_enum(name, *vals) Simplified creation of StrEnum types\nclass ValEnum An ImportEnum that stringifies using values\n\ndef __str__(self)\n@property def name(self)\n\nclass Stateful A base class/mixin for objects that should not serialize all their state\n\ndef __init__(self, *args, **kwargs)\ndef __getstate__(self)\ndef __setstate__(self, state)\n\nclass NotStr Behaves like a str, but isn’t an instance of one\n\ndef __init__(self, s)\ndef __repr__(self)\ndef __str__(self)\ndef __add__(self, b)\ndef __mul__(self, b)\ndef __len__(self)\ndef __eq__(self, b)\ndef __lt__(self, b)\ndef __hash__(self)\ndef __bool__(self)\ndef __contains__(self, b)\ndef __iter__(self)\n\nclass PrettyString Little hack to get strings to show properly in Jupyter.\n\ndef __repr__(self)\n\ndef even_mults(start, stop, n) Build log-stepped array from start to stop in n steps.\ndef num_cpus() Get number of cpus\ndef add_props(f, g, n) Create properties passing each of range(n) to f\ndef typed(f) Decorator to check param and return types at runtime\ndef exec_new(code) Execute code in a new environment and return it\ndef exec_import(mod, sym) Import sym from mod in a new environment\ndef str2bool(s) Case-insensitive convert string s too a bool (y,yes,t,true,on,1-&gt;True)"
  },
  {
    "objectID": "filelist.html#fastcore.dispatch",
    "href": "filelist.html#fastcore.dispatch",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "Basic single and dual parameter dispatch\n\n\ndef lenient_issubclass(cls, types) If possible return whether cls is a subclass of types, otherwise return False.\ndef sorted_topologically(iterable) Return a new list containing all items from the iterable sorted topologically\nclass TypeDispatch Dictionary-like object; __getitem__ matches keys of types using issubclass\n\ndef __init__(self, funcs, bases)\ndef add(self, f) Add type t and function f\ndef first(self) Get first function in ordered dict of type:func.\ndef returns(self, x) Get the return type of annotation of x.\ndef __repr__(self)\ndef __call__(self, *args, **kwargs)\ndef __get__(self, inst, owner)\ndef __getitem__(self, k) Find first matching type that is a super-class of k\n\nclass DispatchReg A global registry for TypeDispatch objects keyed by function name\n\ndef __init__(self)\ndef __call__(self, f)\n\ndef retain_meta(x, res, as_copy) Call res.set_meta(x), if it exists\ndef default_set_meta(self, x, as_copy) Copy over _meta from x to res, if it’s missing\n@typedispatch def cast(x, typ) cast x to type typ (may also change x inplace)\ndef retain_type(new, old, typ, as_copy) Cast new to type of old or typ if it’s a superclass\ndef retain_types(new, old, typs) Cast each item of new to type of matching item in old if it’s a superclass\ndef explode_types(o) Return the type of o, potentially in nested dictionaries for thing that are listy"
  },
  {
    "objectID": "filelist.html#fastcore.docments",
    "href": "filelist.html#fastcore.docments",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "Document parameters using comments.\n\n\ndef docstring(sym) Get docstring for sym for functions ad classes\ndef parse_docstring(sym) Parse a numpy-style docstring in sym\ndef isdataclass(s) Check if s is a dataclass but not a dataclass’ instance\ndef get_dataclass_source(s) Get source code for dataclass s\ndef get_source(s) Get source code for string, function object or dataclass s\ndef get_name(obj) Get the name of obj\ndef qual_name(obj) Get the qualified name of obj\n@delegates(_docments) def docments(elt, full, **kwargs) Generates a docment\ndef extract_docstrings(code) Create a dict from function/class/method names to tuples of docstrings and param lists"
  },
  {
    "objectID": "filelist.html#fastcore.docscrape",
    "href": "filelist.html#fastcore.docscrape",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "Parse numpy-style docstrings\n\n\ndef strip_blank_lines(l) Remove leading and trailing blank lines from a list of lines\nclass Reader A line-based string reader.\n\ndef __init__(self, data)\ndef __getitem__(self, n)\ndef reset(self)\ndef read(self)\ndef seek_next_non_empty_line(self)\ndef eof(self)\ndef read_to_condition(self, condition_func)\ndef read_to_next_empty_line(self)\ndef read_to_next_unindented_line(self)\ndef peek(self, n)\ndef is_empty(self)\n\nclass ParseError\n\ndef __str__(self)\n\nclass NumpyDocString Parses a numpydoc string to an abstract representation\n\ndef __init__(self, docstring, config)\ndef __iter__(self)\ndef __len__(self)\ndef __getitem__(self, key)\ndef __setitem__(self, key, val)\n\ndef dedent_lines(lines, split) Deindent a list of lines maximally"
  },
  {
    "objectID": "filelist.html#fastcore.foundation",
    "href": "filelist.html#fastcore.foundation",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "The L class and helpers for it\n\n\n@contextmanager def working_directory(path) Change working directory to path and return to previous on exit.\ndef add_docs(cls, cls_doc, **docs) Copy values from docs to cls docstrings, and confirm all public methods are documented\ndef docs(cls) Decorator version of add_docs, using _docs dict\ndef coll_repr(c, max_n) String repr of up to max_n items of (possibly lazy) collection c\ndef is_bool(x) Check whether x is a bool or None\ndef mask2idxs(mask) Convert bool mask or index list to index L\ndef is_indexer(idx) Test whether idx will index a single item in a list\nclass CollBase Base class for composing a list of items\n\ndef __init__(self, items)\ndef __len__(self)\ndef __getitem__(self, k)\ndef __setitem__(self, k, v)\ndef __delitem__(self, i)\ndef __repr__(self)\ndef __iter__(self)\n\nclass L Behaves like a list of items but can also index with list of indices or masks\n\ndef __init__(self, items, *rest)\ndef __getitem__(self, idx)\ndef copy(self)\ndef __setitem__(self, idx, o) Set idx (can be list of indices, or mask, or int) items to o (which is broadcast if not iterable)\ndef __eq__(self, b)\ndef sorted(self, key, reverse)\ndef __iter__(self)\ndef __contains__(self, b)\ndef __reversed__(self)\ndef __invert__(self)\ndef __repr__(self)\ndef __mul__(a, b)\ndef __add__(a, b)\ndef __radd__(a, b)\ndef __addi__(a, b)\n@classmethod def split(cls, s, sep, maxsplit)\n@classmethod def range(cls, a, b, step)\ndef map(self, f, *args, **kwargs)\ndef argwhere(self, f, negate, **kwargs)\ndef argfirst(self, f, negate)\ndef filter(self, f, negate, **kwargs)\ndef enumerate(self)\ndef renumerate(self)\ndef unique(self, sort, bidir, start)\ndef val2idx(self)\ndef cycle(self)\ndef map_dict(self, f, *args, **kwargs)\ndef map_first(self, f, g, *args, **kwargs)\ndef itemgot(self, *idxs)\ndef attrgot(self, k, default)\ndef starmap(self, f, *args, **kwargs)\ndef zip(self, cycled)\ndef zipwith(self, *rest)\ndef map_zip(self, f, *args, **kwargs)\ndef map_zipwith(self, f, *rest, **kwargs)\ndef shuffle(self)\ndef concat(self)\ndef reduce(self, f, initial)\ndef sum(self)\ndef product(self)\ndef setattrs(self, attr, val)\n\ndef save_config_file(file, d, **kwargs) Write settings dict to a new config file, or overwrite the existing one.\nclass Config Reading and writing ConfigParser ini files\n\ndef __init__(self, cfg_path, cfg_name, create, save, extra_files, types)\ndef __repr__(self)\ndef __setitem__(self, k, v)\ndef __contains__(self, k)\ndef save(self)\ndef __getattr__(self, k)\ndef __getitem__(self, k)\ndef get(self, k, default)\ndef path(self, k, default)"
  },
  {
    "objectID": "filelist.html#fastcore.imghdr",
    "href": "filelist.html#fastcore.imghdr",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "Recognize image file formats based on their first few bytes.\n\n\ndef test_jpeg(h, f) JPEG data with JFIF or Exif markers; and raw JPEG\ndef test_gif(h, f) GIF (’87 and ’89 variants)\ndef test_tiff(h, f) TIFF (can be in Motorola or Intel byte order)\ndef test_rgb(h, f) SGI image library\ndef test_pbm(h, f) PBM (portable bitmap)\ndef test_pgm(h, f) PGM (portable graymap)\ndef test_ppm(h, f) PPM (portable pixmap)\ndef test_rast(h, f) Sun raster file\ndef test_xbm(h, f) X bitmap (X10 or X11)"
  },
  {
    "objectID": "filelist.html#fastcore.imports",
    "href": "filelist.html#fastcore.imports",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "def is_iter(o) Test whether o can be used in a for loop\ndef is_coll(o) Test whether o is a collection (i.e. has a usable len)\ndef all_equal(a, b) Compares whether a and b are the same length and have the same contents\ndef noop(x, *args, **kwargs) Do nothing\ndef noops(self, x, *args, **kwargs) Do nothing (method)\ndef isinstance_str(x, cls_name) Like isinstance, except takes a type name instead of a type\ndef equals(a, b) Compares a and b for equality; supports sublists, tensors and arrays too\ndef ipython_shell() Same as get_ipython but returns False if not in IPython\ndef in_ipython() Check if code is running in some kind of IPython environment\ndef in_colab() Check if the code is running in Google Colaboratory\ndef in_jupyter() Check if the code is running in a jupyter notebook\ndef in_notebook() Check if the code is running in a jupyter notebook\ndef remove_prefix(text, prefix) Temporary until py39 is a prereq\ndef remove_suffix(text, suffix) Temporary until py39 is a prereq"
  },
  {
    "objectID": "filelist.html#fastcore.meta",
    "href": "filelist.html#fastcore.meta",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "Metaclasses\n\n\ndef test_sig(f, b) Test the signature of an object\nclass FixSigMeta A metaclass that fixes the signature on classes that override __new__\n\ndef __new__(cls, name, bases, dict)\n\nclass PrePostInitMeta A metaclass that calls optional __pre_init__ and __post_init__ methods\n\ndef __call__(cls, *args, **kwargs)\n\nclass AutoInit Same as object, but no need for subclasses to call super().__init__\n\ndef __pre_init__(self, *args, **kwargs)\n\nclass NewChkMeta Metaclass to avoid recreating object passed to constructor\n\ndef __call__(cls, x, *args, **kwargs)\n\nclass BypassNewMeta Metaclass: casts x to this class if it’s of type cls._bypass_type\n\ndef __call__(cls, x, *args, **kwargs)\n\ndef empty2none(p) Replace Parameter.empty with None\ndef anno_dict(f) __annotation__ dictionary withemptycast toNone`, returning empty if doesn’t exist\ndef use_kwargs_dict(keep, **kwargs) Decorator: replace **kwargs in signature with names params\ndef use_kwargs(names, keep) Decorator: replace **kwargs in signature with names params\ndef delegates(to, keep, but) Decorator: replace **kwargs in signature with params from to\ndef method(f) Mark f as a method\ndef funcs_kwargs(as_method) Replace methods in cls._methods with those from kwargs"
  },
  {
    "objectID": "filelist.html#fastcore.net",
    "href": "filelist.html#fastcore.net",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "Network, HTTP, and URL functions\n\n\ndef urlquote(url) Update url’s path with urllib.parse.quote\ndef urlwrap(url, data, headers) Wrap url in a urllib Request with urlquote\nclass HTTP4xxClientError Base class for client exceptions (code 4xx) from url* functions\nclass HTTP5xxServerError Base class for server exceptions (code 5xx) from url* functions\ndef urlopen(url, data, headers, timeout, **kwargs) Like urllib.request.urlopen, but first urlwrap the url, and encode data\ndef urlread(url, data, headers, decode, return_json, return_headers, timeout, **kwargs) Retrieve url, using data dict or kwargs to POST if present\ndef urljson(url, data, timeout) Retrieve url and decode json\ndef urlclean(url) Remove fragment, params, and querystring from url if present\ndef urlsave(url, dest, reporthook, headers, timeout) Retrieve url and save based on its name\ndef urlvalid(x) Test if x is a valid URL\ndef urlrequest(url, verb, headers, route, query, data, json_data) Request for url with optional route params replaced by route, plus query string, and post data\n@patch def summary(self, skip) Summary containing full_url, headers, method, and data, removing skip from headers\ndef urlsend(url, verb, headers, decode, route, query, data, json_data, return_json, return_headers, debug, timeout) Send request with urlrequest, converting result to json if return_json\ndef do_request(url, post, headers, **data) Call GET or json-encoded POST on url, depending on post\ndef start_server(port, host, dgram, reuse_addr, n_queue) Create a socket server on port, with optional host, of type dgram\ndef start_client(port, host, dgram) Create a socket client on port, with optional host, of type dgram\ndef tobytes(s) Convert s into HTTP-ready bytes format\ndef http_response(body, status, hdrs, **kwargs) Create an HTTP-ready response, adding kwargs to hdrs\n@threaded def recv_once(host, port) Spawn a thread to receive a single HTTP request and store in d['r']"
  },
  {
    "objectID": "filelist.html#fastcore.parallel",
    "href": "filelist.html#fastcore.parallel",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "Threading and multiprocessing functions\n\n\ndef threaded(process) Run f in a Thread (or Process if process=True), and returns it\ndef startthread(f) Like threaded, but start thread immediately\ndef startproc(f) Like threaded(True), but start Process immediately\nclass ThreadPoolExecutor Same as Python’s ThreadPoolExecutor, except can pass max_workers==0 for serial execution\n\ndef __init__(self, max_workers, on_exc, pause, **kwargs)\ndef map(self, f, items, *args, **kwargs)\n\n@delegates() class ProcessPoolExecutor Same as Python’s ProcessPoolExecutor, except can pass max_workers==0 for serial execution\n\ndef __init__(self, max_workers, on_exc, pause, **kwargs)\ndef map(self, f, items, *args, **kwargs)\n\ndef parallel(f, items, *args, **kwargs) Applies func in parallel to items, using n_workers\ndef run_procs(f, f_done, args) Call f for each item in args in parallel, yielding f_done\ndef parallel_gen(cls, items, n_workers, **kwargs) Instantiate cls in n_workers procs & call each on a subset of items in parallel."
  },
  {
    "objectID": "filelist.html#fastcore.py2pyi",
    "href": "filelist.html#fastcore.py2pyi",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "def imp_mod(module_path, package) Import dynamically the module referenced in fn\ndef has_deco(node, name) Check if a function node node has a decorator named name\ndef create_pyi(fn, package) Convert fname.py to fname.pyi by removing function bodies and expanding delegates kwargs\n@call_parse def py2pyi(fname, package) Convert fname.py to fname.pyi by removing function bodies and expanding delegates kwargs\n@call_parse def replace_wildcards(path) Expand wildcard imports in the specified Python file."
  },
  {
    "objectID": "filelist.html#fastcore.script",
    "href": "filelist.html#fastcore.script",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "A fast way to turn your python function into a script.\n\n\ndef store_true() Placeholder to pass to Param for store_true action\ndef store_false() Placeholder to pass to Param for store_false action\ndef bool_arg(v) Use as type for Param to get bool behavior\nclass Param A parameter in a function used in anno_parser or call_parse\n\ndef __init__(self, help, type, opt, action, nargs, const, choices, required, default)\ndef set_default(self, d)\n@property def pre(self)\n@property def kwargs(self)\ndef __repr__(self)\n\ndef anno_parser(func, prog) Look at params (annotated with Param) in func and return an ArgumentParser\ndef args_from_prog(func, prog) Extract args from prog\ndef call_parse(func, nested) Decorator to create a simple CLI from func using anno_parser"
  },
  {
    "objectID": "filelist.html#fastcore.style",
    "href": "filelist.html#fastcore.style",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "Fast styling for friendly CLIs.\n\n\nclass StyleCode An escape sequence for styling terminal text.\n\ndef __init__(self, name, code, typ)\ndef __str__(self)\n\nclass Style A minimal terminal text styler.\n\ndef __init__(self, codes)\ndef __dir__(self)\ndef __getattr__(self, k)\ndef __call__(self, obj)\ndef __repr__(self)\n\ndef demo() Demonstrate all available styles and their codes."
  },
  {
    "objectID": "filelist.html#fastcore.test",
    "href": "filelist.html#fastcore.test",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "Helper functions to quickly write tests in notebooks\n\n\ndef test_fail(f, msg, contains, args, kwargs) Fails with msg unless f() raises an exception and (optionally) has contains in e.args\ndef test(a, b, cmp, cname) assert that cmp(a,b); display inputs and cname or cmp.__name__ if it fails\ndef nequals(a, b) Compares a and b for not equals\ndef test_eq(a, b) test that a==b\ndef test_eq_type(a, b) test that a==b and are same type\ndef test_ne(a, b) test that a!=b\ndef is_close(a, b, eps) Is a within eps of b\ndef test_close(a, b, eps) test that a is within eps of b\ndef test_is(a, b) test that a is b\ndef test_shuffled(a, b) test that a and b are shuffled versions of the same sequence of items\ndef test_stdout(f, exp, regex) Test that f prints exp to stdout, optionally checking as regex\ndef test_fig_exists(ax) Test there is a figure displayed in ax\nclass ExceptionExpected Context manager that tests if an exception is raised\n\ndef __init__(self, ex, regex)\ndef __enter__(self)\ndef __exit__(self, type, value, traceback)"
  },
  {
    "objectID": "filelist.html#fastcore.transform",
    "href": "filelist.html#fastcore.transform",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "Definition of Transform and Pipeline\n\n\nclass Transform Delegates (__call__,decode,setup) to (encodes,decodes,setups) if split_idx matches\n\ndef __init__(self, enc, dec, split_idx, order)\n@property def name(self)\ndef __call__(self, x, **kwargs)\ndef decode(self, x, **kwargs)\ndef __repr__(self)\ndef setup(self, items, train_setup)\n\nclass InplaceTransform A Transform that modifies in-place and just returns whatever it’s passed\nclass DisplayedTransform A transform with a __repr__ that shows its attrs\n\n@property def name(self)\n\nclass ItemTransform A transform that always take tuples as items\n\ndef __call__(self, x, **kwargs)\ndef decode(self, x, **kwargs)\n\ndef get_func(t, name, *args, **kwargs) Get the t.name (potentially partial-ized with args and kwargs) or noop if not defined\nclass Func Basic wrapper around a name with args and kwargs to call on a given type\n\ndef __init__(self, name, *args, **kwargs)\ndef __repr__(self)\ndef __call__(self, t)\n\ndef compose_tfms(x, tfms, is_enc, reverse, **kwargs) Apply all func_nm attribute of tfms on x, maybe in reverse order\ndef mk_transform(f) Convert function f to Transform if it isn’t already one\ndef gather_attrs(o, k, nm) Used in getattr to collect all attrs k from self.{nm}\ndef gather_attr_names(o, nm) Used in dir to collect all attrs k from self.{nm}\nclass Pipeline A pipeline of composed (for encode/decode) transforms, setup with types\n\ndef __init__(self, funcs, split_idx)\ndef setup(self, items, train_setup)\ndef add(self, ts, items, train_setup)\ndef __call__(self, o)\ndef __repr__(self)\ndef __getitem__(self, i)\ndef __setstate__(self, data)\ndef __getattr__(self, k)\ndef __dir__(self)\ndef decode(self, o, full)\ndef show(self, o, ctx, **kwargs)"
  },
  {
    "objectID": "filelist.html#fastcore.xdg",
    "href": "filelist.html#fastcore.xdg",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "XDG Base Directory Specification helpers.\n\n\ndef xdg_cache_home() Path corresponding to XDG_CACHE_HOME\ndef xdg_config_dirs() Paths corresponding to XDG_CONFIG_DIRS\ndef xdg_config_home() Path corresponding to XDG_CONFIG_HOME\ndef xdg_data_dirs() Paths corresponding to XDG_DATA_DIRS`\ndef xdg_data_home() Path corresponding to XDG_DATA_HOME\ndef xdg_runtime_dir() Path corresponding to XDG_RUNTIME_DIR\ndef xdg_state_home() Path corresponding to XDG_STATE_HOME"
  },
  {
    "objectID": "filelist.html#fastcore.xml",
    "href": "filelist.html#fastcore.xml",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "Concise generation of XML.\n\n\nclass FT A ‘Fast Tag’ structure, containing tag,children,and attrs\n\ndef __init__(self, tag, cs, attrs, void_, **kwargs)\ndef __setattr__(self, k, v)\ndef __getattr__(self, k)\n@property def list(self)\ndef get(self, k, default)\ndef __repr__(self)\ndef __add__(self, b)\ndef __getitem__(self, idx)\ndef __iter__(self)\n\ndef ft(tag, *c, **kw) Create an FT structure for to_xml()\ndef Html(*c, **kwargs) An HTML tag, optionally preceeded by !DOCTYPE HTML\nclass Safe\n\ndef __html__(self)\n\ndef to_xml(elm, lvl, indent, do_escape) Convert ft element tree into an XML string\ndef highlight(s, lang) Markdown to syntax-highlight s in language lang"
  },
  {
    "objectID": "filelist.html#fastcore.xtras",
    "href": "filelist.html#fastcore.xtras",
    "title": "fastcore Module Documentation",
    "section": "",
    "text": "Utility functions used in the fastai library\n\n\ndef walk(path, symlinks, keep_file, keep_folder, skip_folder, func, ret_folders) Generator version of os.walk, using functions to filter files and folders\ndef globtastic(path, recursive, symlinks, file_glob, file_re, folder_re, skip_file_glob, skip_file_re, skip_folder_re, func, ret_folders) A more powerful glob, including regex matches, symlink handling, and skip parameters\n@contextmanager def maybe_open(f, mode, **kwargs) Context manager: open f if it is a path (and close on exit)\ndef mkdir(path, exist_ok, parents, overwrite, **kwargs) Creates and returns a directory defined by path, optionally removing previous existing directory if overwrite is True\ndef image_size(fn) Tuple of (w,h) for png, gif, or jpg; None otherwise\ndef bunzip(fn) bunzip fn, raising exception if output already exists\ndef loads(s, **kw) Same as json.loads, but handles None\ndef loads_multi(s) Generator of &gt;=0 decoded json dicts, possibly with non-json ignored text at start and end\ndef dumps(obj, **kw) Same as json.dumps, but uses ujson if available\ndef untar_dir(fname, dest, rename, overwrite) untar file into dest, creating a directory if the root contains more than one item\ndef repo_details(url) Tuple of owner,name from ssh or https git repo url\ndef run(cmd, *rest) Pass cmd (splitting with shlex if string) to subprocess.run; return stdout; raise IOError if fails\ndef open_file(fn, mode, **kwargs) Open a file, with optional compression if gz or bz2 suffix\ndef save_pickle(fn, o) Save a pickle file, to a file name or opened file\ndef load_pickle(fn) Load a pickle file from a file name or opened file\ndef parse_env(s, fn) Parse a shell-style environment string or file\ndef expand_wildcards(code) Expand all wildcard imports in the given code string.\ndef dict2obj(d, list_func, dict_func) Convert (possibly nested) dicts (or lists of dicts) to AttrDict\ndef obj2dict(d) Convert (possibly nested) AttrDicts (or lists of AttrDicts) to dict\ndef repr_dict(d) Print nested dicts and lists, such as returned by dict2obj\ndef is_listy(x) isinstance(x, (tuple,list,L,slice,Generator))\ndef mapped(f, it) map f over it, unless it’s not listy, in which case return f(it)\n@patch def readlines(self, hint, encoding) Read the content of self\n@patch def read_json(self, encoding, errors) Same as read_text followed by loads\n@patch def mk_write(self, data, encoding, errors, mode) Make all parent dirs of self, and write data\n@patch def relpath(self, start) Same as os.path.relpath, but returns a Path, and resolves symlinks\n@patch def ls(self, n_max, file_type, file_exts) Contents of path as a list\n@patch def delete(self) Delete a file, symlink, or directory tree\nclass IterLen Base class to add iteration to anything supporting __len__ and __getitem__\n\ndef __iter__(self)\n\n@docs class ReindexCollection Reindexes collection coll with indices idxs and optional LRU cache of size cache\n\ndef __init__(self, coll, idxs, cache, tfm)\ndef __getitem__(self, i)\ndef __len__(self)\ndef reindex(self, idxs)\ndef shuffle(self)\ndef cache_clear(self)\ndef __getstate__(self)\ndef __setstate__(self, s)\n\ndef get_source_link(func) Return link to func in source code\ndef truncstr(s, maxlen, suf, space) Truncate s to length maxlen, adding suffix suf if truncated\ndef sparkline(data, mn, mx, empty_zero) Sparkline for data, with Nones (and zero, if empty_zero) shown as empty column\ndef modify_exception(e, msg, replace) Modifies e with a custom message attached\ndef round_multiple(x, mult, round_down) Round x to nearest multiple of mult\ndef set_num_threads(nt) Get numpy (and others) to use nt threads\ndef join_path_file(file, path, ext) Return path/file if file is a string or a Path, file otherwise\ndef autostart(g) Decorator that automatically starts a generator\nclass EventTimer An event timer with history of store items of time span\n\ndef __init__(self, store, span)\ndef add(self, n) Record n events\n@property def duration(self)\n@property def freq(self)\n\ndef stringfmt_names(s) Unique brace-delimited names in s\nclass PartialFormatter A string.Formatter that doesn’t error on missing fields, and tracks missing fields and unused args\n\ndef __init__(self)\ndef get_field(self, nm, args, kwargs)\ndef check_unused_args(self, used, args, kwargs)\n\ndef partial_format(s, **kwargs) string format s, ignoring missing field errors, returning missing and extra fields\ndef utc2local(dt) Convert dt from UTC to local time\ndef local2utc(dt) Convert dt from local to UTC time\ndef trace(f) Add set_trace to an existing function f\n@contextmanager def modified_env(*delete, **replace) Context manager temporarily modifying os.environ by deleting delete and replacing replace\nclass ContextManagers Wrapper for contextlib.ExitStack which enters a collection of context managers\n\ndef __init__(self, mgrs)\ndef __enter__(self)\ndef __exit__(self, *args, **kwargs)\n\ndef shufflish(x, pct) Randomly relocate items of x up to pct of len(x) from their starting location\ndef console_help(libname) Show help for all console scripts from libname\ndef hl_md(s, lang, show) Syntax highlight s using lang.\ndef type2str(typ) Stringify typ\nclass Unset\n\ndef __repr__(self)\ndef __str__(self)\ndef __bool__(self)\n@property def name(self)\n\ndef nullable_dc(cls) Like dataclass, but default of UNSET added to fields without defaults\ndef flexiclass(cls) Convert cls into a dataclass like make_nullable. Converts in place and also returns the result.\ndef asdict(o) Convert o to a dict, supporting dataclasses, namedtuples, iterables, and __dict__ attrs.\ndef is_typeddict(cls) Check if cls is a TypedDict\ndef is_namedtuple(cls) True if cls is a namedtuple type\ndef flexicache(*funcs) Like lru_cache, but customisable with policy funcs\ndef time_policy(seconds) A flexicache policy that expires cached items after seconds have passed\ndef mtime_policy(filepath) A flexicache policy that expires cached items after filepath modified-time changes\ndef timed_cache(seconds, maxsize) Like lru_cache, but also with time-based eviction"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pysymbol-llm",
    "section": "",
    "text": "If you are new to using nbdev here are some useful pointers to get you started.\n\n\n# make sure pysymbol_llm package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to pysymbol_llm\n$ nbdev_prepare",
    "crumbs": [
      "pysymbol-llm"
    ]
  },
  {
    "objectID": "index.html#developer-guide",
    "href": "index.html#developer-guide",
    "title": "pysymbol-llm",
    "section": "",
    "text": "If you are new to using nbdev here are some useful pointers to get you started.\n\n\n# make sure pysymbol_llm package is installed in development mode\n$ pip install -e .\n\n# make changes under nbs/ directory\n# ...\n\n# compile to have changes apply to pysymbol_llm\n$ nbdev_prepare",
    "crumbs": [
      "pysymbol-llm"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "pysymbol-llm",
    "section": "Usage",
    "text": "Usage\n\nInstallation\nInstall latest from the GitHub repository:\n$ pip install git+https://github.com/AnswerDotAI/pysymbol-llm.git\nor from pypi\n$ pip install pysymbol_llm\n\n\nDocumentation\nDocumentation can be found hosted on this GitHub repository’s pages. Additionally you can find package manager specific guidelines on conda and pypi respectively.",
    "crumbs": [
      "pysymbol-llm"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "pysymbol-llm",
    "section": "How to use",
    "text": "How to use\n\n!pysym2md -h\n\nusage: pysym2md [-h] [--include_no_docstring] [--verbose]\n                [--output_file OUTPUT_FILE]\n                package_name\n\nGenerate a list of symbols corresponding to a python package in a markdown\nformat.\n\npositional arguments:\n  package_name               Name of the Python package\n\noptions:\n  -h, --help                 show this help message and exit\n  --include_no_docstring     Include symbols without docstrings? (default:\n                             False)\n  --verbose                  Turn on verbose logging? (default: True)\n  --output_file OUTPUT_FILE  The output file (default: filelist.md)",
    "crumbs": [
      "pysymbol-llm"
    ]
  }
]